{"ast":null,"code":"import { Delaunay } from \"d3-delaunay\";\nimport { scaleLinear } from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\nexport default function () {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => isFinite(+d[2]) ? +d[2] : 0,\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const {\n        points\n      } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n  let thresholds, values, triangulation;\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear().domain(extent(values)).nice().ticks(thresholds);\n    }\n  }\n  function* tricontours(points) {\n    init(points);\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n  function contour(points, threshold) {\n    init(points);\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n  function* isobands(points) {\n    init(points);\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(p0.concat(p1.map(ring => ring.slice().reverse()))),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n  const contours = function (data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => _ ? (x = _, contours) : x;\n  contours.y = _ => _ ? (y = _, contours) : y;\n  contours.value = _ => _ ? (value = _, contours) : value;\n  contours.thresholds = _ => _ ? (thresholds = _, contours) : thresholds;\n  contours.triangulate = _ => _ ? (triangulate = _, contours) : triangulate;\n  contours.pointInterpolate = _ => _ ? (pointInterpolate = _, contours) : pointInterpolate;\n  contours.ringsort = _ => _ ? (ringsort = _, contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._triangulation = () => triangulation;\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n  function tricontour(triangulation, values, v0 = 0) {\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n    const {\n        halfedges,\n        hull,\n        inedges,\n        triangles\n      } = triangulation,\n      n = values.length;\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n      i = k;\n      path = [];\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[j = next(i)]];\n\n        // is our tour done?\n        if (path.length && ti === path[0].ti && tj === path[0].tj || path.length > 2 * n) break;\n        visited[i] = 1;\n        path.push({\n          ti,\n          tj,\n          a\n        });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha(j = next(j)) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n          while (values[hull[h]] >= v0) {\n            path.push({\n              ti: hull[h],\n              tj: hull[h],\n              a: 0\n            });\n            h = (h + 1) % hull.length;\n          }\n\n          // take that entry\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n          if (edgealpha(i = next(j)) > 0) continue;\n          if (edgealpha(i = prev(j)) > 0) continue;\n        }\n      }\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(({\n          ti,\n          tj,\n          a\n        }) => pointInterpolate(ti, tj, a)));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(Array.from(hull).concat([hull[0]]).map(i => pointInterpolate(i, i, 0)));\n    }\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}","map":{"version":3,"names":["Delaunay","scaleLinear","extent","merge","planarRingsort","x","d","y","value","isFinite","triangulate","from","pointInterpolate","i","j","a","points","triangulation","A","B","ringsort","thresholds","values","init","Array","domain","nice","ticks","tricontours","threshold","polygon","tricontour","type","coordinates","contour","isobands","p0","p1","th0","th","concat","map","ring","slice","reverse","valueMax","contours","data","_","_values","_triangulation","next","prev","v0","halfedges","hull","inedges","triangles","n","length","edgealpha","alpha","u","v","rings","visited","Uint8Array","fill","path","k","ti","tj","push","h","indexOf","every","unshift"],"sources":["C:/Users/mathi/Desktop/it/1/me/node_modules/d3-tricontour/src/tricontour.js"],"sourcesContent":["import {Delaunay} from \"d3-delaunay\";\nimport {scaleLinear} from \"d3-scale\";\nimport extent from \"./extent.js\";\nimport merge from \"./merge.js\";\nimport planarRingsort from \"./ringsort.js\";\n\nexport default function() {\n  // accessors\n  let x = d => d[0],\n    y = d => d[1],\n    value = d => (isFinite(+d[2]) ? +d[2] : 0),\n    triangulate = Delaunay.from,\n    pointInterpolate = (i, j, a) => {\n      const { points } = triangulation;\n      const A = [points[2 * i], points[2 * i + 1]],\n        B = [points[2 * j], points[2 * j + 1]];\n      return [a * B[0] + (1 - a) * A[0], a * B[1] + (1 - a) * A[1]];\n    },\n    ringsort = planarRingsort;\n\n  let thresholds, values, triangulation;\n\n  function init(points) {\n    triangulation = triangulate(points, x, y);\n    values = Array.from(points, value);\n    if (typeof thresholds !== \"object\") {\n      thresholds = scaleLinear()\n        .domain(extent(values))\n        .nice()\n        .ticks(thresholds);\n    }\n  }\n\n  function* tricontours(points) {\n    init(points);\n\n    for (const threshold of thresholds) {\n      const polygon = tricontour(triangulation, values, threshold);\n      yield {\n        type: \"MultiPolygon\",\n        coordinates: polygon,\n        value: threshold\n      };\n    }\n  }\n\n  function contour(points, threshold) {\n    init(points);\n\n    return {\n      type: \"MultiPolygon\",\n      coordinates: tricontour(triangulation, values, threshold),\n      value: threshold\n    };\n  }\n\n  function* isobands(points) {\n    init(points);\n\n    let p0, p1, th0;\n    for (const th of thresholds) {\n      if (p1) p0 = p1;\n      p1 = merge(tricontour(triangulation, values, th));\n      if (p0) {\n        yield {\n          type: \"MultiPolygon\",\n          coordinates: ringsort(\n            p0.concat(p1.map(ring => ring.slice().reverse()))\n          ),\n          value: th0,\n          valueMax: th\n        };\n      }\n      th0 = th;\n    }\n  }\n\n  const contours = function(data) {\n    return [...tricontours(data)];\n  };\n\n  // API\n  contours.x = _ => (_ ? ((x = _), contours) : x);\n  contours.y = _ => (_ ? ((y = _), contours) : y);\n  contours.value = _ => (_ ? ((value = _), contours) : value);\n  contours.thresholds = _ => (_ ? ((thresholds = _), contours) : thresholds);\n  contours.triangulate = _ => (_ ? ((triangulate = _), contours) : triangulate);\n  contours.pointInterpolate = _ =>\n    _ ? ((pointInterpolate = _), contours) : pointInterpolate;\n  contours.ringsort = _ =>\n    _ ? ((ringsort = _), contours) : ringsort;\n  contours.contours = tricontours;\n  contours.contour = contour;\n  contours.isobands = isobands;\n\n  // expose the internals (useful for debugging, not part of the API)\n  contours._values = () => values;\n  contours._triangulation = () => triangulation;\n\n  return contours;\n\n  // navigate a triangle\n  function next(i) {\n    return i % 3 === 2 ? i - 2 : i + 1;\n  }\n  function prev(i) {\n    return i % 3 === 0 ? i + 2 : i - 1;\n  }\n\n  function tricontour(triangulation, values, v0 = 0) {\n    // sanity check\n    for (const d of values) if (!isFinite(d)) throw [\"Invalid value\", d];\n\n    const { halfedges, hull, inedges, triangles } = triangulation,\n      n = values.length;\n\n    function edgealpha(i) {\n      return alpha(triangles[i], triangles[next(i)]);\n    }\n    function alpha(i, j) {\n      const u = values[i],\n        v = values[j];\n      if (u <= v0 && v >= v0 && u < v) {\n        return (v0 - u) / (v - u);\n      }\n    }\n\n    // create the path from the first exit; cancel visited halfedges\n    const rings = [],\n      visited = new Uint8Array(halfedges.length).fill(0);\n    let path, i, j, k, a;\n    for (k = 0; k < halfedges.length; k++) {\n      if (visited[k]) continue;\n\n      i = k;\n      path = [];\n\n      while ((a = edgealpha(i)) > 0) {\n        const [ti, tj] = [triangles[i], triangles[(j = next(i))]];\n\n        // is our tour done?\n        if (\n          (path.length && (ti === path[0].ti && tj === path[0].tj)) ||\n          path.length > 2 * n\n        )\n          break;\n\n        visited[i] = 1;\n        path.push({ ti, tj, a });\n\n        // jump into the adjacent triangle\n        if ((j = halfedges[i]) > -1) {\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          if (edgealpha((j = next(j))) > 0) {\n            i = j;\n            continue;\n          }\n          // debugger;\n        }\n\n        // or follow the hull\n        else {\n          let h = (hull.indexOf(triangles[i]) + 1) % hull.length;\n\n          while (values[hull[h]] < v0) {\n            // debugger;\n            h = (h + 1) % hull.length;\n          }\n\n          while (values[hull[h]] >= v0) {\n            path.push({ ti: hull[h], tj: hull[h], a: 0 });\n            h = (h + 1) % hull.length;\n          }\n\n          // take that entry\n          j = inedges[hull[h]];\n          path.push({\n            ti: hull[h],\n            tj: triangles[j],\n            a: alpha(hull[h], triangles[j])\n          });\n\n          if (edgealpha((i = next(j))) > 0) continue;\n          if (edgealpha((i = prev(j))) > 0) continue;\n        }\n      }\n\n      if (path.length) {\n        path.push(path[0]);\n        rings.push(path.map(({ ti, tj, a }) => pointInterpolate(ti, tj, a)));\n      }\n    }\n\n    // special case all values on the hull are >=v0, add the hull\n    if (hull.every(d => values[d] >= v0)) {\n      rings.unshift(\n        Array.from(hull)\n          .concat([hull[0]])\n          .map(i => pointInterpolate(i, i, 0))\n      );\n    }\n\n    return ringsort(rings); // return [rings] if we don't need to sort\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}